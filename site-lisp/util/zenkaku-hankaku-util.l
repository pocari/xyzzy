(provide "zenkaku-hankaku-util")
(export
 '(hankaku-to-zenkaku-region
   zenkaku-to-hankaku-region
   hankaku-to-zenkaku-selection
   zenkaku-to-hankaku-selection))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (require "util/common-macros"))

(defvar *zenkaku-hankaku-table*
  '(("É@" . "ß")
    ("ÉA" . "±")
    ("ÉB" . "®")
    ("ÉC" . "≤")
    ("ÉD" . "©")
    ("ÉE" . "≥")
    ("ÉF" . "™")
    ("ÉG" . "¥")
    ("ÉH" . "´")
    ("ÉI" . "µ")
    ("ÉJ" . "∂")
    ("ÉK" . "∂ﬁ")
    ("ÉL" . "∑")
    ("ÉM" . "∑ﬁ")
    ("ÉN" . "∏")
    ("ÉO" . "∏ﬁ")
    ("ÉP" . "π")
    ("ÉQ" . "πﬁ")
    ("ÉR" . "∫")
    ("ÉS" . "∫ﬁ")
    ("ÉT" . "ª")
    ("ÉU" . "ªﬁ")
    ("ÉV" . "º")
    ("ÉW" . "ºﬁ")
    ("ÉX" . "Ω")
    ("ÉY" . "Ωﬁ")
    ("ÉZ" . "æ")
    ("É[" . "æﬁ")
    ("É\" . "ø")
    ("É]" . "øﬁ")
    ("É_" . "¿ﬁ")
    ("É`" . "¡")
    ("Éa" . "¡ﬁ")
    ("Éb" . "Ø")
    ("Éc" . "¬")
    ("Éd" . "¬ﬁ")
    ("Ée" . "√")
    ("Éf" . "√ﬁ")
    ("Ég" . "ƒ")
    ("Éh" . "ƒﬁ")
    ("Éi" . "≈")
    ("Éj" . "∆")
    ("Ék" . "«")
    ("Él" . "»")
    ("Ém" . "…")
    ("Én" . " ")
    ("Éo" . " ﬁ")
    ("Ép" . " ﬂ")
    ("Éq" . "À")
    ("Ér" . "Àﬁ")
    ("És" . "Àﬂ")
    ("Ét" . "Ã")
    ("Éu" . "Ãﬁ")
    ("Év" . "Ãﬂ")
    ("Éw" . "Õ")
    ("Éx" . "Õﬁ")
    ("Éy" . "Õﬂ")
    ("Éz" . "Œ")
    ("É{" . "Œﬁ")
    ("É|" . "Œﬂ")
    ("É}" . "œ")
    ("ÉÄ" . "—")
    ("ÉÅ" . "“")
    ("ÉÇ" . "”")
    ("ÉÉ" . "¨")
    ("ÉÑ" . "‘")
    ("ÉÖ" . "≠")
    ("ÉÜ" . "’")
    ("Éá" . "Æ")
    ("Éà" . "÷")
    ("Éâ" . "◊")
    ("Éä" . "ÿ")
    ("Éã" . "Ÿ")
    ("Éå" . "⁄")
    ("Éç" . "€")
    ("Éé" . "Éé")
    ("Éè" . "‹")
    ("Éê" . "Éê")
    ("Éë" . "Éë")
    ("Éí" . "¶")
    ("Éì" . "›")
    ("Éî" . "≥ﬁ")
    ("Åu" . "¢")
    ("ÅA" . "§")
    ("ÅB" . "°")
    ("ÅE" . "•")
    ("ÅJ" . "ﬁ")
    ("ÅK" . "ﬂ")
    ("Å[" . "∞")
    ("Åv" . "£")
    ("ÅI" . "!")
    ("Åh" . "\"")
    ("Åî" . "#")
    ("Åê" . "$")
    ("Åì" . "%")
    ("Åï" . "&")
    ("Åf" . "'")
    ("Å@" . " ")
    ("Åi" . "(")
    ("Åj" . ")")
    ("Åñ" . "*")
    ("Å{" . "+")
    ("ÅC" . ",")
    ("Å[" . "-")
    ("ÅD" . ".")
    ("Å^" . "/")
    ("ÇO" . "0")
    ("ÇP" . "1")
    ("ÇQ" . "2")
    ("ÇR" . "3")
    ("ÇS" . "4")
    ("ÇT" . "5")
    ("ÇU" . "6")
    ("ÇV" . "7")
    ("ÇW" . "8")
    ("ÇX" . "9")
    ("ÅF" . ":")
    ("ÅG" . ";")
    ("ÅÉ" . "<")
    ("ÅÅ" . "=")
    ("ÅÑ" . ">")
    ("ÅH" . "?")
    ("Åó" . "@")
    ("Ç`" . "A")
    ("Ça" . "B")
    ("Çb" . "C")
    ("Çc" . "D")
    ("Çd" . "E")
    ("Çe" . "F")
    ("Çf" . "G")
    ("Çg" . "H")
    ("Çh" . "I")
    ("Çi" . "J")
    ("Çj" . "K")
    ("Çk" . "L")
    ("Çl" . "M")
    ("Çm" . "N")
    ("Çn" . "O")
    ("Ço" . "P")
    ("Çp" . "Q")
    ("Çq" . "R")
    ("Çr" . "S")
    ("Çs" . "T")
    ("Çt" . "U")
    ("Çu" . "V")
    ("Çv" . "W")
    ("Çw" . "X")
    ("Çx" . "Y")
    ("Çy" . "Z")
    ("Åm" . "[")
    ("Åè" . "\\")
    ("Ån" . "]")
    ("ÅO" . "^")
    ("ÅQ" . "_")
    ("ÅM" . "`")
    ("ÇÅ" . "a")
    ("ÇÇ" . "b")
    ("ÇÉ" . "c")
    ("ÇÑ" . "d")
    ("ÇÖ" . "e")
    ("ÇÜ" . "f")
    ("Çá" . "g")
    ("Çà" . "h")
    ("Çâ" . "i")
    ("Çä" . "j")
    ("Çã" . "k")
    ("Çå" . "l")
    ("Çç" . "m")
    ("Çé" . "n")
    ("Çè" . "o")
    ("Çê" . "p")
    ("Çë" . "q")
    ("Çí" . "r")
    ("Çì" . "s")
    ("Çî" . "t")
    ("Çï" . "u")
    ("Çñ" . "v")
    ("Çó" . "w")
    ("Çò" . "x")
    ("Çô" . "y")
    ("Çö" . "z")
    ("Åo" . "{")
    ("Åb" . "|")
    ("Åp" . "}")
    ("Å`" . "~")
    )
  )

(defmacro each-char-region ((ch from to) &body body)
  (with-gensyms (start-char end-char counter next)
    (let ((xfrom from)
	  (xto  to))
      `(dotimes (,counter (- ,xto ,xfrom) nil)
	 (let* ((,start-char (+ ,xfrom ,counter))
		(,end-char (+ ,start-char 1))
		(,ch (buffer-substring ,start-char ,end-char)))
	   (when (not (or (string= "ﬁ" ,ch) (string= "ﬂ" ,ch)))
	     (setq ,next (buffer-substring ,end-char (+ 1 ,end-char)))
	     (if (or (string= "ﬁ" ,next) (string= "ﬂ" ,next))
		 (setq ,ch (concat ,ch ,next)))
	     ,@body))))))

(defun zenkaku-hankaku-convert-char (ch pair-method get-method)
  (let ((converted))
    (if (setq converted (funcall get-method (apply pair-method (list ch *zenkaku-hankaku-table* :test #'equal))))
	converted
      ch)))

(defun replace-region (from to replacement)
  (save-excursion
    (save-restriction
      (narrow-to-region from to)
      (delete-region from to)
      (insert replacement))))

(defun zenkaku-to-hankaku-char (ch)
  (zenkaku-hankaku-convert-char ch #'assoc #'cdr))

(defun hankaku-to-zenkaku-char (ch)
  (zenkaku-hankaku-convert-char ch #'rassoc #'car))

(defun hankaku-zenkaku-convert (from to method)
  (let ((converted "")
	(c))
    (if (> from to)
	(rotatef from to))
    (each-char-region (ch from to)
		      (setq converted (concat converted (funcall method ch))))
    (replace-region from to converted)))


(defun hankaku-to-zenkaku-region (from to)
  (interactive "r")
  (hankaku-zenkaku-convert from to #'hankaku-to-zenkaku-char))


(defun zenkaku-to-hankaku-region (from to)
  (interactive "r")
  (hankaku-zenkaku-convert from to #'zenkaku-to-hankaku-char))

(defun hankaku-to-zenkaku-selection ()
  (interactive "*p")
  (when (pre-selection-p)
    (hankaku-zenkaku-convert (selection-mark) (selection-point) #'hankaku-to-zenkaku-char)))

(defun zenkaku-to-hankaku-selection ()
  (interactive "*p")
  (when (pre-selection-p)
    (hankaku-zenkaku-convert (selection-mark) (selection-point) #'zenkaku-to-hankaku-char)))
